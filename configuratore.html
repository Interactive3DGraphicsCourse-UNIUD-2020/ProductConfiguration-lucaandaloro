<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<title>Configuratore - Progetto Vespa Piaggio</title>
		<link rel="icon" href="images/site/Vespa.png">
		<!-- CSS FILES -->
		<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/uikit@latest/dist/css/uikit.min.css">
    		<link rel="stylesheet" type="text/css" href="css/stile.css">
    	<script src="http://code.jquery.com/jquery-1.10.1.min.js"></script>
		<script src="lib/three.min.js"></script>
		<script src="lib/BufferGeometryUtils.js"></script>
		<script src="lib/stats.min.js"></script>
		<script src="lib/Coordinates.js"></script>
		<script src="lib/OrbitControls.js"></script>
		<script src="lib/GLTFLoader.js"></script>
		<script src='lib/dat.gui.min.js'></script>
		<script src="js/materiali.js"></script>
		<script src="js/modello.js"></script>
		<script src="js/cambiaAmbiente.js"></script>
		<script src="js/cambiaScocca.js"></script>
		<script src="js/cambiaSella.js"></script>
		<script src="js/cambiaManopola.js"></script>
		<script src="js/luceAmbientale.js"></script>
		<script src="js/mostraPosizioneLuce.js"></script>
		
		
	
		
			<!-- shaders -->

			<script type="text/x-glsl" id="vertex_glossy">
				
				varying vec3 vNormal;
				varying vec3 vPosition;
				varying vec3 wPosition;
				varying vec2 vUv;


				void main() {
					vec4 vPos = modelViewMatrix * vec4( position, 1.0 ); // da object space a view space
					vPosition = vPos.xyz;
					wPosition = (modelMatrix * vec4( position, 1.0 )).xyz; // posizione del vertice
					vNormal = normalize(normalMatrix * normal);  // normale da object space a view space
					vUv = uv;
					gl_Position = projectionMatrix * vPos;
				}
				</script>
		
			<script type="text/x-glsl" id="fragment_glossy">
				varying vec3 vNormal;
				varying vec3 vPosition;
				varying vec3 wPosition;
				varying vec2 vUv;
				uniform vec3 cspec;
				
				uniform samplerCube envMap; // texture del cubo tutte le facce del cubo
				
				const float PI = 3.14159;

				vec3 FSchlick(float vDoth, vec3 f0) {
					return f0 + (vec3(1.0)-f0)*pow(1.0 - vDoth,5.0);
				}

		

			// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations
			vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
				return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
			}

				void main() {
					vec3 n = normalize( vNormal );
					vec3 v = normalize( -vPosition);

					// Da qui in poi abbiamo la parte dedicata alla riflessione

					vec3 worldN = inverseTransformDirection( n, viewMatrix ); // Portiamo la normale da view space in world space perchè l'envmap è in world space
					vec3 worldV = cameraPosition - wPosition ; // Portiamo il vettore v (che va dal punto alla camera) da view space in world space facendo posizioneDellaCamera - poszioneDelVertice

					vec3 r = normalize( reflect(-worldV,worldN)); // r vector from objet to cubemaps

					// small quantity to prevent divisions by 0
					float nDotv = max(dot( n, v ),0.000001);
					vec3 fresnel = FSchlick(nDotv, cspec);

					// negate x to account for how cubemap is displayed on background

					vec3 envLight = textureCube( envMap, vec3(-r.x, r.yz)).rgb; 

					// dobbiamo linearize con il gamma decoding
					envLight = pow( envLight, vec3(2.2));

					vec3 outRadiance = fresnel*envLight; 

					// gamma encode the final value, per sRGB gamma è 1/2.2 = 0.45.
					
					gl_FragColor = vec4(pow( outRadiance, vec3(1.0/2.2)), 1.0);
				}
			</script>
			<script type="text/x-glsl" id="vertex_color">
					varying vec3 vNormal;
					varying vec3 vPosition;
			
					void main() {
						vec4 vPos = modelViewMatrix * vec4( position, 1.0 ); // da object space a view space
						vPosition = vPos.xyz;
						vNormal = normalMatrix * normal; // normale da object space a view space
						gl_Position = projectionMatrix * vPos;
					}
			</script>
			
			<script type="text/x-glsl" id="fragment_color">
						varying vec3 vNormal;
						varying vec3 vPosition;
						uniform vec3 pointLightPosition; // in world space
						uniform vec3 pointLightPosition2; // in world space
						uniform vec3 clight;
						uniform vec3 cspec;  // f0
						uniform float roughness; //  alpha
						const float PI = 3.14159;
			
						vec3 FSchlick(float vDoth, vec3 f0) {
							return f0 + (vec3(1.0)-f0)*pow(1.0 - vDoth,5.0);
						}
			
						float DGGX(float NoH, float alpha) {
							float alpha2 = alpha * alpha;
							float k = NoH*NoH * (alpha2 - 1.0) + 1.0;
							return alpha2 / (PI * k * k );
						}
						
						// G1 fa parte di GSmith
						float G1(float nDotv, float alpha) {
							float alpha2 = alpha*alpha;
							return 2.0 * (nDotv / (nDotv + sqrt(alpha2 + (1.0-alpha2)*nDotv*nDotv )));
						}
			
						float GSmith(float nDotv, float nDotl, float alpha) {
							return G1(nDotl,alpha)*G1(nDotv,alpha);
						}
			
						void main() {
							// From World space to View Space
							vec4 lPosition = viewMatrix * vec4( pointLightPosition, 1.0 ); // da world space a View Space.
							vec4 lPosition2 = viewMatrix * vec4( pointLightPosition2, 1.0 ); //da world space a View Space. 
							vec3 l = normalize(lPosition.xyz - vPosition.xyz);
							vec3 l2 = normalize(lPosition2.xyz - vPosition.xyz);
							vec3 n = normalize( vNormal );  // interpolation destroys normalization, so we have to normalize
							vec3 v = normalize( -vPosition); // si utilizza il meno (-) perchè siamo in viewspace
							vec3 h = normalize( v + l);
							vec3 h2 = normalize( v + l2);
							// small quantity to prevent divisions by 0, perchè solitamente sono al denomintaore quindi dobbiamo escludere il valore 0
							float nDotl = max(dot( n, l ),0.00001);
							float nDotl2 = max(dot( n, l2 ),0.00001);
							float lDoth = max(dot( l, h ),0.00001);
							float lDoth2 = max(dot( l2, h2 ),0.00001);
							float nDoth = max(dot( n, h ),0.00001);
							float nDoth2 = max(dot( n, h2 ),0.00001);
							float vDoth = max(dot( v, h ),0.00001);
							float vDoth2 = max(dot( v, h2 ),0.00001);
							float nDotv = max(dot( n, v ),0.00001);
							float alpha = roughness * roughness; // Utilizzato in unreal engine per dare più effetto
							vec3 specularBRDF = FSchlick(vDoth, cspec)*GSmith(nDotv,nDotl, alpha)*DGGX(nDoth,alpha)/(4.0*nDotl*nDotv);
							vec3 specularBRDF2 = FSchlick(vDoth2, cspec)*GSmith(nDotv,nDotl2, alpha)*DGGX(nDoth2,alpha)/(4.0*nDotl2*nDotv);
							
							vec3 outRadiance = PI*  ((clight *nDotl * specularBRDF) + (clight * nDotl2 * specularBRDF2)); //  equazione di rendering con le BRDF con le due luci
							// gamma encode the final value, per sRGB gamma è 1/2.2 = 0.45.
							gl_FragColor = vec4(pow( outRadiance, vec3(1.0/2.2)), 1.0); 
						}
			</script>
					

		<script type="text/x-glsl" id="vertex_textures">
				attribute vec4 tangent; //  tangent (sarebbe la cordinata "s")
				varying vec3 vNormal;
				varying vec3 vPosition;
				
				varying vec2 vUv;
				varying vec3 vTangent;
				varying vec3 vBitangent;
		
				void main() {
					vec4 vPos = modelViewMatrix * vec4( position, 1.0 );
					vPosition = vPos.xyz;
					vNormal = normalize(normalMatrix * normal); // normale da object space a view space
					vec3 objectTangent = vec3( tangent.xyz );
					vec3 transformedTangent = normalMatrix * objectTangent; // tangente da object space a view space 
					vTangent = normalize( transformedTangent );
					// w is 1 or -1 depending on the sign of det( M tangent )
					vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w ); 
					vUv = uv;
					gl_Position = projectionMatrix * vPos;
				}
				</script>
		
				<script type="text/x-glsl" id="fragment_textures">
					varying vec3 vNormal;
					varying vec3 vTangent;
					varying vec3 vBitangent;
					varying vec3 vPosition;
					
					varying vec2 vUv;
					uniform vec3 pointLightPosition; // in world space
					
					uniform vec3 clight;
					uniform sampler2D specularMap;
					uniform sampler2D diffuseMap;
					uniform sampler2D roughnessMap;
					uniform sampler2D normalMap;
					
					uniform vec2 normalScale;
					uniform vec2 textureRepeat;
					const float PI = 3.14159;
		
					vec3 cdiff;
					vec3 cspec;
					float roughness;
		
					vec3 FSchlick(float vDoth, vec3 f0) {
						return f0 + (vec3(1.0)-f0)*pow(1.0 - vDoth,5.0);
					}
		
					float DGGX(float NoH, float alpha) {
						float alpha2 = alpha * alpha;
						float k = NoH*NoH * (alpha2 - 1.0) + 1.0;
						return alpha2 / (PI * k * k );
					}
		
					float G1(float nDotv, float alpha) {
						float alpha2 = alpha*alpha;
						return 2.0 * (nDotv / (nDotv + sqrt(alpha2 + (1.0-alpha2)*nDotv*nDotv )));
					}
		
					float GSmith(float nDotv, float nDotl, float alpha) {
						return G1(nDotl,alpha)*G1(nDotv,alpha);
					}
		
					void main() {
						vec4 lPosition = viewMatrix * vec4( pointLightPosition, 1.0 ); // Portiamo la posizione della luce in view space
						vec3 l = normalize(lPosition.xyz - vPosition.xyz); 
						vec3 normal = normalize( vNormal );
						vec3 tangent = normalize( vTangent );
						vec3 bitangent = normalize( vBitangent );
						// matrix to convert bewtween tangent space and view space, all value are view space
						mat3 vTBN = mat3( tangent, bitangent, normal ); 
						vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0; // read normal and value from color rgb to coordinates xyz
						vec3 n = normalize( vTBN * mapN  );  // Moltiplico la matrice vTBN per il vettore mapN per passare da tangent space a View space e interpolation destroys normalization, so we have to normalize
						vec3 v = normalize( -vPosition);
						vec3 h = normalize( v + l);
						// small quantity to prevent divisions by 0
						// Utilizziamo max per non prendere valori negativi
						float nDotl = max(dot( n, l ),0.000001); 
						float lDoth = max(dot( l, h ),0.000001);
						float nDoth = max(dot( n, h ),0.000001);
						float vDoth = max(dot( v, h ),0.000001);
						float nDotv = max(dot( n, v ),0.000001);
		
						cdiff = texture2D( diffuseMap, vUv*textureRepeat ).rgb;
						// texture in sRGB, linearize.
						
						cdiff = pow( cdiff, vec3(2.2));
						cspec = texture2D( specularMap, vUv*textureRepeat ).rgb;
						// texture in sRGB, linearize
						cspec = pow( cspec, vec3(2.2));
						roughness = texture2D( roughnessMap, vUv*textureRepeat).r; // no need to linearize roughness map
						vec3 fresnel = FSchlick(vDoth, cspec);
						float alpha = roughness * roughness;
						// diffuse + specular
						vec3 BRDF = (vec3(1.0)-fresnel)*cdiff/PI + fresnel*GSmith(nDotv,nDotl, alpha)*DGGX(nDoth,alpha)/ (4.0*nDotl*nDotv); // Abbiamo sia la parte diffusiva (lambertiana) che speculare (Microfaccette)
						vec3 outRadiance = PI* clight * nDotl * BRDF;
						// gamma encode the final value, per sRGB gamma è 1/2.2 = 0.45.
						
						gl_FragColor = vec4(pow( outRadiance, vec3(1.0/2.2)), 1.0);
					}
				</script>

				<script type="text/x-glsl" id="vertex_textures_ao">
					attribute vec4 tangent;
					varying vec3 vNormal;
					varying vec3 vPosition;
					
					varying vec2 vUv;
					varying vec3 vTangent;
					varying vec3 vBitangent;
			
					void main() {
						vec4 vPos = modelViewMatrix * vec4( position, 1.0 );
						vPosition = vPos.xyz;
						vNormal = normalize(normalMatrix * normal); // Normale da object space a view space
						vec3 objectTangent = vec3( tangent.xyz );
						vec3 transformedTangent = normalMatrix * objectTangent;
						vTangent = normalize( transformedTangent );
						// w is 1 or -1 depending on the sign of det( M tangent )
						vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
						vUv = uv;
						gl_Position = projectionMatrix * vPos;
					}
					</script>
			
					<script type="text/x-glsl" id="fragment_textures_ao">
						varying vec3 vNormal;
						varying vec3 vTangent;
						varying vec3 vBitangent;
						varying vec3 vPosition;
						
						varying vec2 vUv;
						uniform vec3 pointLightPosition; // in world space
						uniform vec3 ambientLight;
						uniform vec3 clight;
						uniform sampler2D specularMap;
						uniform sampler2D diffuseMap;
						uniform sampler2D roughnessMap;
						uniform sampler2D normalMap;
						uniform sampler2D aoMap;
						uniform vec2 normalScale;
						uniform vec2 textureRepeat;
						const float PI = 3.14159;
			
						vec3 cdiff;
						vec3 cspec;
						float roughness;
			
						vec3 FSchlick(float vDoth, vec3 f0) {
							return f0 + (vec3(1.0)-f0)*pow(1.0 - vDoth,5.0);
						}
			
						float DGGX(float NoH, float alpha) {
							float alpha2 = alpha * alpha;
							float k = NoH*NoH * (alpha2 - 1.0) + 1.0;
							return alpha2 / (PI * k * k );
						}
			
						float G1(float nDotv, float alpha) {
							float alpha2 = alpha*alpha;
							return 2.0 * (nDotv / (nDotv + sqrt(alpha2 + (1.0-alpha2)*nDotv*nDotv )));
						}
			
						float GSmith(float nDotv, float nDotl, float alpha) {
							return G1(nDotl,alpha)*G1(nDotv,alpha);
						}
			
						void main() {
							vec4 lPosition = viewMatrix * vec4( pointLightPosition, 1.0 ); 
							vec3 l = normalize(lPosition.xyz - vPosition.xyz);
							vec3 normal = normalize( vNormal );
							vec3 tangent = normalize( vTangent );
							vec3 bitangent = normalize( vBitangent );
							// matrix to convert bewtween tangent space and view space
							mat3 vTBN = mat3( tangent, bitangent, normal );
							vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0; // read normal and value from color rgb to coordinates xyz
							vec3 n = normalize( vTBN * mapN  );  // Moltiplico la matrice vTBN per il vettore mapN per passare da tangent space a eye space e interpolation destroys normalization, so we have to normalize
							vec3 v = normalize( -vPosition);
							vec3 h = normalize( v + l);
							// small quantity to prevent divisions by 0
							float nDotl = max(dot( n, l ),0.000001);
							float lDoth = max(dot( l, h ),0.000001);
							float nDoth = max(dot( n, h ),0.000001);
							float vDoth = max(dot( v, h ),0.000001);
							float nDotv = max(dot( n, v ),0.000001);
			
							cdiff = texture2D( diffuseMap, vUv*textureRepeat ).rgb;
							// texture in sRGB, linearize.
							cdiff = pow( cdiff, vec3(2.2));
							cspec = texture2D( specularMap, vUv*textureRepeat ).rgb;
							// texture in sRGB, linearize
							cspec = pow( cspec, vec3(2.2));
							roughness = texture2D( roughnessMap, vUv*textureRepeat).r; // no need to linearize roughness map
							vec3 fresnel = FSchlick(vDoth, cspec);
							float alpha = roughness * roughness;
							vec3 BRDF = fresnel*GSmith(nDotv,nDotl, alpha)*DGGX(nDoth,alpha)/ (4.0*nDotl*nDotv); // non utilizzo la parte diffusiva nella BRDF per dare un effetto più metallico! Ma viene utilizzata per l'illuminazione ambientale
							vec3 outRadiance = PI* clight * nDotl * BRDF + ambientLight*cdiff*texture2D( aoMap, vUv ).xyz;
							// gamma encode the final value
							gl_FragColor = vec4(pow( outRadiance, vec3(1.0/2.2)), 1.0);
						}
					</script>

				<script type="text/x-glsl" id="vertex_irradiance">	
					varying vec3 vNormal;
					varying vec3 vPosition;


					void main() {
						vec4 vPos = modelViewMatrix * vec4( position, 1.0 );
						vPosition = vPos.xyz;
						
						vNormal = normalize(normalMatrix * normal);	// normale da object space a view space
						gl_Position = projectionMatrix * vPos;
					}
					</script>
			
					<script type="text/x-glsl" id="fragment_irradiance">
						varying vec3 vNormal;
						varying vec3 vPosition;
						uniform vec3 cdiff;
						uniform samplerCube irradianceMap;
						const float PI = 3.14159;
			
					
			
					// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations
					vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
						return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
					}
			
						void main() {
							vec3 n = normalize( vNormal );
							
							vec3 v = normalize( -vPosition);
							vec3 worldN = inverseTransformDirection( n, viewMatrix ); // la cubemaps è in worldspace quindi dobbiamo spostarci con la normale in world space
							
							// negate x to account for how cubemap is displayed on background
							vec3 irradiance = textureCube( irradianceMap, -worldN).rgb; // In questo caso utilizziamo la normale per trovare il texels della cubemaps corretto
							// texture in sRGB, linearize, gamma decoding
							irradiance = pow( irradiance, vec3(2.2));
							vec3 outRadiance = cdiff*irradiance;
							// gamma encode the final value, per sRGB gamma è 1/2.2 = 0.45. 
							gl_FragColor = vec4(pow( outRadiance, vec3(1.0/2.2)), 1.0);
						}
					</script>
			<!-- shaders -->
	</head>
	

	<body>
			<!--HEADER-->
		<header id="header" style="background-color: #fff;" data-uk-sticky="show-on-up: true; animation: uk-animation-fade; media: @l">
			<div class="uk-container">
				<nav id="navbar" data-uk-navbar="mode: click;">
					<div class="uk-navbar-center nav-overlay">
						<a class="uk-navbar-item uk-logo" href="#" title="Logo"><img src="images/site/Vespa.png" alt="Logo"></a>
					</div>
					
				</nav>
			</div>
		</header>
    <!--/HEADER-->
    
    <!-- NAVIGATION -->
    <div class="top-wrap uk-position-relative uk-light uk-background-secondary">
		<div class="uk-container">
			<nav class="nav-scroll">
				<ul class="uk-subnav uk-flex uk-flex-between uk-flex-nowrap">
					<li><a href="index.html">Home</a></li>
					<li class="uk-active"><a href="configuratore.html">Configuratore</a></li>
					<li><a href="#">Chi Siamo</a></li>
					<li><a href="#">Contatti</a></li>
					<li><a href="#">Dove siamo</a></li>
				</ul>
			</nav>
    </div>
    </div>
		<!-- /NAVIGATION -->
			
    <div class="uk-section uk-section-default">
			<div class="uk-container uk-margin-remove-right">
				<div class="uk-grid" data-ukgrid="">
					<div class="uk-width-2-3@m">
            <script id="can" src="js/main.js"></script>
					
					</div>
					<div class="uk-width-1-3@m">
						
						<h4 class="uk-heading-line uk-text-bold"><span>Configura la tua <img data-src="images/site/Vespa.png" width="95px" alt="" uk-img></span></h4>
						<div class="uk-tile uk-tile-small uk-tile-muted uk-border-rounded">
							<h5 class="uk-heading-line"><span>Seleziona materiale scocca</span></h5>
							<img class="uk-border-rounded" src="images/site/configuratore/color_azzurro.png" width="90" onClick="cambiaMateriale('azzurro')">
							<img class="uk-border-rounded" src="images/site/configuratore/chrome.jpg" width="90"  onClick="cambiaMateriale('cromato')">
							<img class="uk-border-rounded" src="images/site/configuratore/ruggine.jpg" width="90" onClick="cambiaMateriale('ruggine')">
							<h5 class="uk-heading-line"><span>Seleziona materiale sella</span></h5>
							<img class="uk-border-rounded" src="images/site/configuratore/pelle.jpg" width="90px" onClick="cambiaMaterialeSella('Leather001_2K')">
							<img class="uk-border-rounded" src="images/site/configuratore/stoffa.png" width="90px"  onClick="cambiaMaterialeSella('Fabric030_2K')">
							<img class="uk-border-rounded" src="images/site/configuratore/tessuto.png" width="90px" onClick="cambiaMaterialeSella('Fabric008_2K')">
							<h5 class="uk-heading-line"><span>Seleziona materiale manopola</span></h5>
							<img class="uk-border-rounded" src="images/site/configuratore/manopola_nera.png" width="90px" onClick="cambiaMaterialeManopola('Tiles072_2K')">
							<img class="uk-border-rounded" src="images/site/configuratore/manopola_bianca.png" width="90px"  onClick="cambiaMaterialeManopola('TexturesCom')">
							
						
							<h5 class="uk-heading-line"><span>Seleziona sfondo</span></h5>
							<img class="uk-border-rounded" uk-tooltip="title: Studio; pos: bottom" src="images/site/configuratore/background_studio.png" width="90"  onClick="cambiaAmbiente('studio')">
							<img class="uk-border-rounded" uk-tooltip="title: Garage; pos: bottom"  src="images/site/configuratore/background_garage.png" width="90" onClick="cambiaAmbiente('garage')">
							<img class="uk-border-rounded" uk-tooltip="title: Giardino; pos: bottom"  src="images/site/configuratore/background_bosco.png" width="90" onClick="cambiaAmbiente('bosco')">
							
							<h5 class="uk-heading-line"><span>Accendi/spegni luce ambientale:</span></h5>
							<label class="uk-switch" for="on-1">
								<input type="checkbox" id="on-1" onClick="aggiungiLuceAmbientale('')">
								<div class="uk-switch-slider uk-switch-on-off round"></div>
							  </label>
							  <h5 class="uk-heading-line"><span>Mostra posizione luce principale:</span></h5>
							<label class="uk-switch2" for="on-2">
								<input type="checkbox" id="on-2" onClick="mostraPosizioneLuce('')">
								<div class="uk-switch2-slider uk-switch2-on-off round"></div>
							  </label>
							  <hr class="uk-divider-small">
							<h1 class="uk-heading-medium" id="prezzo">€ 1300</h1>
							<button class="uk-button uk-button-primary">Acquista</button>
						</div>
						
						
					</div>
				</div>
			</div>
		</div>
		
		<!-- FOOTER -->
		<footer id="footer" class="uk-section uk-section-secondary uk-padding-remove-bottom">
		
			<div class="uk-text-center uk-padding uk-padding-remove-horizontal">
        <span class="uk-text-small uk-text-center">© 2021 | <a href="https://github.com/Interactive3DGraphicsCourse-UNIUD-2020/ProductConfiguration-lucaandaloro" title="Created by Luca Andaloro">Created by Luca Andaloro</a> | Built with <a href="http://getuikit.com" title="Visit UIkit 3 site" target="_blank" data-uk-tooltip><span data-uk-icon="uikit"></span></a></span>
			</div>
		</footer>
		<!-- /FOOTER -->
		
		
		<!-- JS FILES -->
		<script src="https://cdn.jsdelivr.net/npm/uikit@latest/dist/js/uikit.min.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/uikit@latest/dist/js/uikit-icons.min.js"></script>
	</body>
</html>